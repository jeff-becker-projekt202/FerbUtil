<?php

declare(strict_types=1);

namespace Ferb\Util\Config;

use Ferb\Util\Config\ConfigSection;
use Ferb\Util\Config\ConfigPath;
use Ferb\Util\FluentIterator;

abstract class ConfigProvider
{
    private $data;
    private $prefix;
    private $delimiter;

    protected function __construct($prefix = '', $delimiter = '')
    {
        $this->prefix = $prefix ?? '';
        $this->delimiter = $delimiter;
    }

    /**
     * gets a configuration value for the specified key.
     *
     * @return array [$success bool, $value mixed]
     */
    public function get(string $key): array
    {
        $this->ensure_data();
        if (isset($this->data[$key])) {
            return [true, $this->data[$key]];
        }
        return [false, null];
    }

    /**
     * Returns the immediate descendant configuration keys for the given parent path
     * based on this provider's data and the set of keys returned by the preceeding
     * providers.
     *
     * @param array  $previous_keys keys generated by the preceeding providers
     * @param string $parent_path   the parent path
     *
     * @return array the child keys
     */
    public function get_child_keys($previous_keys, string $parent_path)
    {
        $child_keys = $this->get_my_children($parent_path)
            ->append($previous_keys)
        ;

        return FluentIterator::from($child_keys)
            ->unique(function ($x, $y) {
                $x = $x instanceof ConfigSection ? $x->path() : $x;
                $y = $y instanceof ConfigSection ? $y->path() : $y;

                return \strcasecmp($x, $y);
            })
            ->order_by_asc(ConfigPath::compare_paths())
        ;
    }

    private function ensure_data()
    {
        if (!isset($this->data)) {
            $this->data = $this->get_data();
        }
    }

    abstract protected function get_values(): array;

    protected function get_data(): array
    {
        $result = [];

        foreach ($this->get_values() as $key => $value) {
            $path = $this->normalize($key);
            if ($this->include($path)) {
                $result[$path] = $value;
            }
        }

        return $result;
    }

    protected function normalize($key): string
    {
        if (!empty($this->delimiter)) {
            $key = \str_replace($this->delimiter, ConfigPath::KeyDelimiter, $key);
        }

        return $key;
    }

    protected function include(string $key): bool
    {
        return empty($this->prefix) || 0 === stripos($key, $this->prefix);
    }

    protected static function flatten($arr)
    {
        $result = [];
        foreach ($arr as $key => $value) {
            if (is_array($value)) {
                foreach (self::flatten($value) as $child_key => $child_value) {
                    $path = ConfigPath::combine([$key, $child_key]);
                    $result[$path] = strval($child_value);
                }
            } else {
                $result[$key] = $value;
            }
        }

        return $result;
    }

    private function get_my_children($parent_path)
    {
        $this->ensure_data();
        $parent_path = trim($parent_path);
        $base = FluentIterator::from(array_keys($this->data));

        if (!empty($parent_path)) {
            $parent_path = $parent_path.ConfigPath::KeyDelimiter;
            $base = $base->filter(function ($key) use ($parent_path) {
                return 0 === stripos($key, $parent_path);
            });
        }

        $prefix_len = strlen($parent_path);
        $mine = $base->map(function ($key) use ($prefix_len) {
            $index = stripos($key, ConfigPath::KeyDelimiter, $prefix_len);
            if (false === $index) {
                return substr($key, $prefix_len);
            }

            return substr($key, $prefix_len, $index - $prefix_len);
        });

        return FluentIterator::from($mine);
    }

    public static function from_array($data)
    {
        return new class($data) extends ConfigProvider {
            private $underlying;

            public function __construct($data)
            {
                parent::__construct('', '');
                $this->underlying = $data ?? [];
            }

            protected function get_values(): array
            {
                return parent::flatten($this->underlying);
            }
        };
    }
    public static function from_environment()
    {
        return new class() extends ConfigProvider {
            protected function get_values(): array
            {
                return $_ENV;
            }
        };
    }
    public static function from_include($file)
    {
        return new class($file) extends ConfigProvider {
            private $file;

            public function __construct($file)
            {
                parent::__construct('', '');
                $this->file = $file;
            }

            protected function get_values(): array
            {
                $data = (function () {
                    return include $this->file;
                })();
                if (false === $data) {
                    return [];
                }

                return parent::flatten($data);
            }
        };
    }

    public static function from_json($file)
    {
        return new class($file) extends ConfigProvider {
            private $file;

            public function __construct($file)
            {
                parent::__construct('', '');
                $this->file = $file;
            }

            protected function get_values(): array
            {
                $txt = \file_get_contents($this->file);
                $data = \json_decode($txt);

                return parent::flatten($data);
            }
        };
    }
}
